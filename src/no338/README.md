# 题意

给一个非负整数`num`。计算从`0`到`num`之间所有数字的二进制表示中，有多少个`1`。将他们作为一个数组返回。

举例：   
提供数字`5`，应该返回`[0,1,1,2,1,2]`。

后续讨论：
这个题目可以很简单地得出一个时间复杂度为`O(n*sizeof(integer))`的解决方案。但你能想出一个时间复杂度接近`O(n)`的解决方案吗？   
同时空间复杂度也必须是O(n)。
不用使用语言内置的API来解决该问题。

# 思路

## 思路1

这道题不考虑效率的情况下，可以使用位运算符对每个数进行运算，从而获得每个数二进制表示的`1`的数量。时间复杂度为`O(n*sizeof(integer))`。

## 思路2

首先我们先了解到数值除以2在二进制中的情况。如`12`的二进制表示是`1100‬`，而`12/2 = 6`,`6`的二进制表示是`110`。   
我们可以看到，一个数除以2，那么在二进制的表示中，相当于该数字的二进制数值**右移1位**。也就是说该数字除了被移除的那一位数字，其他都是可以确定的。   
通过观察可以发现当二进制表示最后一位为`1`时，则数值为奇数，那么`A`二进制表示最后一位的是否为`1`也迎刃而解。

由此得出结论，一个数值`A`的二进制表示`1`的数量，等于`A`除以2的数值`B`的二进制`1`的数量 加上`A`二进制表示最后一位的表示。
